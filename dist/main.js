const t=new Set,e=new Set,o=new Set;let s=1;const i={linear:t=>t,inQuad:t=>t*t,outQuad:t=>2*t-t*t};exports.time=0,exports.delta=0,exports.max=50,exports.setTimescale=(t=>s=t),exports.onUpdate=(t=>e.add(t)),exports.onAfterUpdate=(t=>o.add(t));const a="undefined"!=typeof window?window.requestAnimationFrame:void 0;exports.init=(()=>{exports.time=0,exports.delta=0,s=1,t.clear(),e.clear(),o.clear()}),exports.update=(s=>{exports.delta=Math.min(exports.max,s-exports.time),t.size>0&&(t.forEach(t=>{t.autostart&&t.start()}),t.clear()),e.forEach(t=>t(.001*exports.delta)),o.forEach(t=>t(.001*exports.delta)),a&&a(exports.update),exports.time=s}),a&&a(exports.update),exports.tween=((o,a,r=.4,d=0)=>{const h={autostart:!0,obj:o,from:{},to:a,dur:r,easing:"outQuad",el:0,delay:d,onStarted:[],onCompleted:[],onKilled:[],after:[],start:function(t=0){for(var o in this.to)this.from[o]=this.obj[o];for(var s of(e.add(this.evt),this.onStarted))s.call(h);0!=t&&(this.delay+=t),this.delay<0&&this.update(Math.abs(this.delay))},update:function(t){if(this.delay>0){if(this.delay-=t*s,this.delay>0)return;t=Math.abs(this.delay)}this.el+=t*s;var o=this.el-this.dur;for(var a in o>0&&(this.el-=o),this.to)this.obj[a]=this.from[a]+i[this.easing](this.el/this.dur)*(this.to[a]-this.from[a]);if(this.el===this.dur){for(var r of(e.delete(this.evt),this.onCompleted))r.call(h);for(var d of(this.obj=void 0,this.after))d.start(-o)}},kill:function(t=!1){if(this.obj){for(var o of(e.delete(this.evt),this.onKilled))o.call(h);if(t)for(var s in this.to)this.obj[s]=this.to[s];this.obj=void 0}},append:function(t){return t.autostart=!1,this.after.push(t),t}};return h.evt=h.update.bind(h),t.add(h),h});